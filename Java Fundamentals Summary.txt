Java Fundamentels - summary

1. TERMINAL-OUTPUT

System.out.print("tekst")
-tekst = free to choose-

\n => new line
\r => return

println => output + ENTER

\t => tab
\" => " (quotes)

\b => backspace
\f => formfeed

\' => '
\\ => \


2. KEYBOARD-INPUT
import java.util.Scanner;

Scanner keyboard = new Scanner (System.in)
-keyboard = free to choose-

var x = keyboard.nextvar();

-var = free to choose variable-
-x = free to choose variableName-
-keyboard = free to choose-
-var = replace by free to choose variable(same as var)-

3. VARIABLES

3.2. PRIMITIVE DATATYPES
Integers: (byte, short),int, long
Floating point: float, double
Characters: char
Text: String
Booleans (false/true): boolean

3.3. PROPERTIES

can be:
Private		-> Only used inside the Class
Default		-> Use inside the package
Protected	-> Use inside package and SubClasses
Public		-> Useable in all classes

Static		-> ClassVariable not InstanceVariable
Final		-> Constant, can't be changed
type		-> Primitive datatype or ReferenceType (Object)
initValue	-> Initial value of variable

4. OPERATORS
+-*/=
% 	-> rest of division

++	-> +1
--	-> -1

== 	-> equals
!= 	-> equals not
> 	-> higher then
<	-> smaller then
>=	-> higher then or equals
<=	-> smaller then or equals

&&	-> AND
||	-> OR
!	-> NOT

+=	-> op1 += op2	-> op1 = op1 + op2
-=	-> op1 -= op2	-> op1 = op1 - op2
*=	-> op1 *= op2	-> op1 = op1 * op2
/=	-> op1 /= op2	-> op1 = op1 / op2
%=	-> op1 %= op2	-> op1 = op1 % op2
&=	-> op1 &= op2	-> op1 = op1 & op2
|=	-> op1 |= op2	-> op1 = op1 | op2

?:	-> op1?op2:op3
-op1 = condition-
-? op2 = if condition is true give op2-
-: op3 = if condition is false give op3-

.	-> Go to underneath qualified name
[]	-> Array
(,)	-> List of parameters
(type)	-> typeconversion (-type = new type to be given) -> (type)value
(new) 	-> create new object	-> new Object()

instance of	-> check if object is instance of specified class 
-> op instanceof class


5. STATEMENTS

5.1. IF

if 	(condition){
	statements;}

-condition = uses operators-
-statement(s) = to do when condition is true-


5.2. IF/ELSE

if	(conditon){
	statement;
} else {
statements;
}

-if = see IF-Statements-
-else-statement(s) = to do when condition is false-


6.LOOPS
6.1. WHILE-LOOP

while 	(condition){
	statements;

1) checking condition
2) to do if condition is true
3) checking condition again

6.2. DO/WHILE-LOOP

do {
	statements;}
while (condition);

1) do statement(s)
2) checking condition
3) if condition is true do statement(s) again

6.3. FOR-LOOP
for (initialisation;condition;in.decrement){
	statements;
}

1) initialisation
2) checking condition
3) if condition is true, do statement(s)
4) increment or decrement
5) checking condition again

! SWITCH-STATEMENT = Predetermined if-else statement !
=> (this condition = this statement)

switch (variableName) {
case 1: otherVariableName = value; break;
case 2: idem
etc ...
-break = optional-

! final variables !
=> can never be changed
=> names in caps

6.4. FOREACH-LOOP

for (type element: arrayName) {
	statements;
}
-element = free choice of name-


7. METHODS

public (static abstract final) void/type name (param 1, param 2) throws exeption {
	statements;
	return result;
}

-can be public, private, protected default-
-static = ClassMethod not instanceMethod-

-abstract = Abstract methods have no body, 
should be overriden when implemented-
-final = Can't be overriden by SubClass-

-void = optional-
-type = optional-
-name = free to choose-
-parameters = optional, but when given forced to use-

-throws exception = Defines possible exceptions to accure 
when the method is used-
-statements = to do-
-return type as var if static-

type => returns a value of the given type
void => returns action

When method is stored in seperate class:
to call => classname.methodname

7.Bis. Methods with variabel number of params
returnType methodName (type ... params);
-type ... is same use as array of that type-

7.1. SETTERS & GETTERS

-basic setters-
public void setX (type x) {
	this.x = x;
}

-> used for constructors to acces variable

-basic getters-
public type getX () {
	return result;
}

-> used to call a given variable
-> return must give a result of given type

(can be auto-generated by ALT + INSERT)

7.2. METHOD OVERLOADING

Methods can have the same name, the method will be chosen by choice of given params.

-> calling methods: ClassName.method();

7.3. OBJECT-METHODS

toString()		-> should be overriden in classes to be usefull
equals() & hashcode ()	-> used to compare 2 objects
(can be auto-generated by ALT + INSERT)


8. OOP (Object Oriented Programming)

An Object:
IS 	-> properties
HAS 	-> methods

purpose: 
Trying to keep properties unaccesible outside the class.
Use of class by call of methods.

Creation of an object	-> Object name = new Object();

8.1. CONSTRUCTORS

Basic method to create a new object
public|private|protected|default ClassName (params){
	initialisation;
}

-> Used to create new object from given class
(can be auto-generated by ALT + INSERT)

->using this can make a constructor with lesser params 
call a constructor with more params


8.2. STRING VS STRINGBUILDER

! Strings are immutable !
StringBuilder


8.3. FORMATTER

Formatter name = new Formatter();
name.format(text,variables)

To enter specified variable within the text use:
%b	-> boolean
%c	-> character

%d	-> int
%f	-> floating point number
%s	-> String

%e	-> scientific notation
%n	-> new line


9. ARRAYS

dataType [] arrayName = new dataType [length] {parameters};
-{parameters} = optional-

9.Bis. MULTI-DIMENSIONAL ARRAYS

dataType [][] name = new dataType [lenghtFirstArray][lenghtSecondArray]{{parametersFirstArray},{parametersSecondArray}};


10. CLASSES

public abstract final class ClassName extends SuperClass implements Interface {
//class body
}

-public or default-
-abstract = can only be used to be distracted to other classes-
-final = can not be used to be distracted to other classes-
-extends SuperClass = SubClass distracted from SuperClass (or abstract)-
-implements Interface = Uses interface and thus must implement methods-


11. RELATIONS

11.1. ASSOCIATIONS

A class using a method from another Class (must be imported)
(Class has a OtherClass)

11.2. AGGREGATIONS

A class ownes another class.

11.3. COMPOSITIONS

A class is made out of different other classes/objects.

11.Bis HIGH COHESION

One class, one task.

12. INHERITANCE

(Class is a OtherClass)

12.1. SUBCLASSES & SUPERCLASSES

Subclasses inherite all properties and methods.
Methods can be overriden and added.

abstract classes: 
->Can only be distracted to other classes
->Can not extend superclasses
->Can only have abstract methods

defining abstrac classes:
public abstract class AbstractClassName {
...
}

defining subclasses:
class Subclass extends SuperClass {
...
}

inheritance of properties and methods:
private		->classbound
default 	->packagebound
protected	->package and subclasses
public		->all classes

->Variables can be hidden by giving it another value in subclasses.

to override methods:
@Override
public void methodNameSuperClass (params) {
...
}

12.2. POLYMORPHISM

Subclasses inherite superclasses but can take different formes.

12.Bis SUBCLASS CONSTRUCTORS

Constructors are not inhereted from superclass.
Each subclass should have its own constructor.


13. ENUMERATIONS

public enum Name {
	FINALS;
}


14. SIMPLE CLASSES

14.1 WRAPPERS

Byte		-> byte
Short		-> short
Integer		-> int
Long		-> long
Float		-> float
Double		-> double
BigInteger	-> Integer with unlimited precision
BigDecimal	-> Decimal with unlimited precision
Boolean		-> boolean
Character	-> char

->Wrapper-objects are immutable (just as String)
->Wrapper-class has also static members 
(such as, MAX_VALUE, MIN_VALUE, NaN, NEGETIVE_INFINITY, POSITIVE_INFINITY)

14.2. DATE & TIME
14.2.1. INSTANT

Instant now = Instant.now();

-> gives the exact time when and where called to.
-> has methods for calculations from a given time and/or date

14.2.2. HUMAN DATE & TIME
Month
-> instances for all months

DaysOfWeek
-> instances for all dayNames

14.2.3. LOCAL DATE & TIME

1) LocalTime	-> Local time in hours, minutes, seconds, ...
2) LocalDate	-> Local date in years, months, days, ...
3) LocalDateTime-> Local date and time combined

14.2.4. TIMEZONES

ZoneId name = ZoneId.of("Region/City")

1) ZoneId = gives date and/or time from given region and city.
2) ZoneOffSet = gives date and/or time from given difference of UTC

14.2.5. TIMEDURATION

1) Duration = differences of the Instant-class
2) ChronoUnit = enumeration of different time-units between 2 given times.
3) Period = gives time-differences in human notations

14.2.6. DATE-FORMATTING

DateTimeFormatter = uses patterns to format time and/or date in specified format (see also 8.3. FORMATTER)

tY	-> yyyy (years)
ty	-> yy (years)
tB	-> month, entire name
tb	-> month, abbreviated
tm	-> mm (month)
td	-> dd (day)
tH	-> hours /24
tl	-> hours /12
tM	-> mm (minutes)
tS	-> ss (seconds)


15. INTERFACES

Definition: collection of abstract methods for use in objects.

- Gives different objects indentical behaviour 
(even in case of different superclass).
- Implementing methods
- Indirect use of object (by interface not the class itself).
- Can be used for collecting constant values.

-> In general name should end on -able

public interface InterfaceName extends SuperInts {
	...
}

-> All methods are implicitly public and abstract
-> All params are also implicitly public, static and final.
-> Methods can be static or void.
-> New object can be made out of interface
(InterfaceName name = new Object(); -where the Object implements the right interface)


16. NESTED AND ANONYMOUS CLASSES

-> Class within another Class

16.1. INNER CLASSES

public class OuterClass {
	...
	public class InnerClass {
	...
	}
	...
}

-full name = OuterClass.InnerClass-

to make an object of the InnerClass:
- from withing the OuterClass	-> InnerClass name = new InnerClass ();
- from another Class		-> OuterClass outerName = new OuterClass();
+	-> OuterClass.InnerClass innerName = outerName.new Innerclass();

to reference a this of OuterClass within an InnerClas:
use: OuterClass.this

16.2. LOCAL INNER CLASSES

-> inner class within a method of outer class
-> they have only acces to variables within the method 
that are therefor implicitly final

public class OuterClass {
	public void aMethod () {
	final var = x;
	class LocalInnerClass {
	...
	}
}}

16.3. ANONYMOUS INNER CLASSES

-> Inner Classes without name, defined when created into Objects

public class OuterClass {
	...
	public void method () {
	SuperClass object1 = new SuperClass () {
	//Implementations and/or Overrides
	};
	Interface object2 = new Interface() {
	//Implementations
	};
	}
{

16.4. STATIC NESTED CLASSES

public class OuterClass {
	public static class InnerClass {
	}
}

-> Static Nested classes can not acces directly 
outerclass-properties & -methods.

Other example of Static nested class (as enum):
public class OuterClass {
	public enum EnumClass {
	...
	}
}

(nested enums can not be defined within methods)


17. EXCEPTION HANDLING

- Handels exceptions grouped and separated from rest of code.
- Does call stack (back to front)
- Can handle exception at top of hierarchy 
(so an exception for a superclass can be handled as wel for all subclasses)

catching exceptions:

try {
	statements;
	} catch (ExceptionName en) {
	//actions to do
	} catch (OtherException oe) {
	//actions to do
	}

catching multiple exceptions

try {
	statements;
	} catch (ExceptionName|OtherException e) {
	//actions todo
	}

with finally codeblock:

try {
	...
	} catch () {
	...
	} finally {
	...
}

-> even when Exception hit, finally-block will always be carried out.

throw exceptions:

public void method () throws Exception {
	if (condition) throw new exception ();
	else statements;
}

17.1. EXCEPTION-CLASSES

public class ExceptionName extends ExistingException {
	ExceptionConstructors for ex. message, cause;
}


18. GENERICS




sources :
Java 11 Fundamentals - Noël Vaes

