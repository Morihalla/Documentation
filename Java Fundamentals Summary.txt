Java Fundamentels - summary

1. TERMINAL-OUTPUT
---------------------------

System.out.print("tekst")
-tekst = free to choose-

\n => new line
\r => return

println => output + ENTER

\t => tab
\" => " (quotes)

\b => backspace
\f => formfeed

\' => '
\\ => \

_________________
2. KEYBOARD-INPUT
---------------------------------------------------------

import java.util.Scanner;

Scanner keyboard = new Scanner (System.in)
-keyboard = free to choose-

var x = keyboard.nextvar();

-var = free to choose variable-
-x = free to choose variableName-
-keyboard = free to choose-
-var = replace by free to choose variable(same as var)-

_____________
3. VARIABLES
-------------------------------------------------------------
________________________
3.2. PRIMITIVE DATATYPES
-----------------------------------

Integers: (byte, short),int, long
Floating point: float, double
Characters: char
Text: String
Booleans (false/true): boolean
________________
3.3. PROPERTIES
---------------------------------------------------------

can be:
Private		-> Only used inside the Class
Default		-> Use inside the package
Protected	-> Use inside package and SubClasses
Public		-> Useable in all classes

Static		-> ClassVariable not InstanceVariable
Final		-> Constant, can't be changed
type		-> Primitive datatype or ReferenceType (Object)
initValue	-> Initial value of variable

_____________
4. OPERATORS
---------------------------------------------------

+-*/=
% 	-> rest of division

++	-> +1
--	-> -1

== 	-> equals
!= 	-> equals not
> 	-> higher then
<	-> smaller then
>=	-> higher then or equals
<=	-> smaller then or equals

&&	-> AND
||	-> OR
!	-> NOT

+=	-> op1 += op2	-> op1 = op1 + op2
-=	-> op1 -= op2	-> op1 = op1 - op2
*=	-> op1 *= op2	-> op1 = op1 * op2
/=	-> op1 /= op2	-> op1 = op1 / op2
%=	-> op1 %= op2	-> op1 = op1 % op2
&=	-> op1 &= op2	-> op1 = op1 & op2
|=	-> op1 |= op2	-> op1 = op1 | op2

?:	-> op1?op2:op3
-op1 = condition-
-? op2 = if condition is true give op2-
-: op3 = if condition is false give op3-

.	-> Go to underneath qualified name
[]	-> Array
(,)	-> List of parameters
(type)	-> typeconversion (-type = new type to be given) -> (type)value
(new) 	-> create new object	-> new Object()

instance of	-> check if object is instance of specified class 
-> op instanceof class

______________
5. STATEMENTS
----------------------------------------------------------
________
5.1. IF
---------------------------------------------------

if 	(condition){
	statements;}

-condition = uses operators-
-statement(s) = to do when condition is true-
_____________
5.2. IF/ELSE
----------------------------------------------------

if	(conditon){
	statement;
} else {
statements;
}

-if = see IF-Statements-
-else-statement(s) = to do when condition is false-

________
6.LOOPS
----------------------------------------------------
_______________
6.1. WHILE-LOOP
--------------------------------

while 	(condition){
	statements;

1) checking condition
2) to do if condition is true
3) checking condition again
___________________
6.2. DO/WHILE-LOOP
--------------------------------------------------

do {
	statements;}
while (condition);

1) do statement(s)
2) checking condition
3) if condition is true do statement(s) again
______________
6.3. FOR-LOOP
-----------------------------------------------------------

for (initialisation;condition;in.decrement){
	statements;
}

1) initialisation
2) checking condition
3) if condition is true, do statement(s)
4) increment or decrement
5) checking condition again

! SWITCH-STATEMENT = Predetermined if-else statement !
=> (this condition = this statement)

switch (variableName) {
case 1: otherVariableName = value; break;
case 2: idem
etc ...
-break = optional-

! final variables !
=> can never be changed
=> names in caps
__________________
6.4. FOREACH-LOOP
-------------------------------------

for (type element: arrayName) {
	statements;
}
-element = free choice of name-

__________
7. METHODS
-------------------------------------------------------------------------

public (static abstract final) void/type name (param 1, param 2) 
throws exeption {
	statements;
	return result;
}

-can be public, private, protected default-
-static = ClassMethod not instanceMethod-

-abstract = Abstract methods have no body, 
should be overriden when implemented-
-final = Can't be overriden by SubClass-

-void = optional-
-type = optional-
-name = free to choose-
-parameters = optional, but when given forced to use-

-throws exception = Defines possible exceptions to accure 
when the method is used-
-statements = to do-
-return type as var if static-

type => returns a value of the given type
void => returns action

When method is stored in seperate class:
to call => classname.methodname
_____________________________________________
7.Bis. METHODS WITH VARIABLE NUMBER OF PARAMS
---------------------------------------------

returnType methodName (type ... params);
-type ... is same use as array of that type-
________________________
7.1. SETTERS & GETTERS
------------------------------------------------

-basic setters-
public void setX (type x) {
	this.x = x;
}

-> used for constructors to acces variable

-basic getters-
public type getX () {
	return result;
}

-> used to call a given variable
-> return must give a result of given type

(can be auto-generated by ALT + INSERT)
_______________________
7.2. METHOD OVERLOADING
-----------------------------------------------------------

Methods can have the same name, the method will be chosen 
by choice of given params.

-> calling methods: ClassName.method();
___________________
7.3. OBJECT-METHODS
-------------------------------------------------------------------------

toString()		-> should be overriden in classes to be usefull
equals() & hashcode ()	-> used to compare 2 objects
(can be auto-generated by ALT + INSERT)

____________________________________
8. OOP (Object Oriented Programming)
----------------------------------------------------------

An Object:
IS 	-> properties
HAS 	-> methods

purpose: 
Trying to keep properties unaccesible outside the class.
Use of class by call of methods.

Creation of an object	-> Object name = new Object();
__________________
8.1. CONSTRUCTORS
------------------------------------------------------

Basic method to create a new object
public|private|protected|default ClassName (params){
	initialisation;
}

-> Used to create new object from given class
(can be auto-generated by ALT + INSERT)

->using this can make a constructor with lesser params 
call a constructor with more params

____________________________
8.2. STRING VS STRINGBUILDER
-------------------------------

! Strings are immutable !
StringBuilder
______________
8.3. FORMATTER
----------------------------------------------------

Formatter name = new Formatter();
name.format(text,variables)

To enter specified variable within the text use:
%b	-> boolean
%c	-> character

%d	-> int
%f	-> floating point number
%s	-> String

%e	-> scientific notation
%n	-> new line

__________
9. ARRAYS
--------------------------------------------------------------------------

dataType [] arrayName = new dataType [length] {parameters};
-{parameters} = optional-
________________________________
9.Bis. MULTI-DIMENSIONAL ARRAYS
------------------------------------------------------------------------

dataType [][] name = new dataType [lenghtFirstArray][lenghtSecondArray]{{parametersFirstArray},{parametersSecondArray}};

____________
10. CLASSES
-----------------------------------------------------------------------------

public abstract final class ClassName extends SuperClass implements Interface {
//class body
}

-public or default-
-abstract = can only be used to be distracted to other classes-
-final = can not be used to be distracted to other classes-
-extends SuperClass = SubClass distracted from SuperClass (or abstract)-
-implements Interface = Uses interface and thus must implement methods-

______________
11. RELATIONS
-------------------------------------------------------------
___________________
11.1. ASSOCIATIONS
-------------------------------------------------------------

A class using a method from another Class (must be imported)
(Class has a OtherClass)
__________________
11.2. AGGREGATIONS
------------------------------

A class ownes another class.
___________________
11.3. COMPOSITIONS
-------------------------------------------------------

A class is made out of different other classes/objects.
____________________
11.Bis HIGH COHESION
------------------------

One class, one task.

________________
12. INHERITANCE
-------------------------------------------------

(Class is a OtherClass)
_______________________________
12.1. SUBCLASSES & SUPERCLASSES
-------------------------------------------------

Subclasses inherite all properties and methods.
Methods can be overriden and added.

abstract classes: 
->Can only be distracted to other classes
->Can not extend superclasses
->Can only have abstract methods

defining abstrac classes:
public abstract class AbstractClassName {
...
}

defining subclasses:
class Subclass extends SuperClass {
...
}

inheritance of properties and methods:
private		->classbound
default 	->packagebound
protected	->package and subclasses
public		->all classes

->Variables can be hidden by giving it another value in subclasses.

to override methods:
@Override
public void methodNameSuperClass (params) {
...
}
__________________
12.2. POLYMORPHISM
---------------------------------------------------------------

Subclasses inherite superclasses but can take different formes.
______________________________
12.Bis SUBCLASS CONSTRUCTORS
-------------------------------------------------

Constructors are not inhereted from superclass.
Each subclass should have its own constructor.

_________________
13. ENUMERATIONS
--------------------------------------------------------

public enum Name {
	FINALS;
}

____________________
14. SIMPLE CLASSES
----------------------------------------------------------------------------
_______________
14.1 WRAPPERS
----------------------------------------------------------------------------

Byte		-> byte
Short		-> short
Integer		-> int
Long		-> long
Float		-> float
Double		-> double
BigInteger	-> Integer with unlimited precision
BigDecimal	-> Decimal with unlimited precision
Boolean		-> boolean
Character	-> char

->Wrapper-objects are immutable (just as String)
->Wrapper-class has also static members 
(such as, MAX_VALUE, MIN_VALUE, NaN, NEGETIVE_INFINITY, POSITIVE_INFINITY)
_________________
14.2. DATE & TIME
---------------------------------------------------------------
________________
14.2.1. INSTANT
---------------------------------------------------------------

Instant now = Instant.now();

-> gives the exact time when and where called to.
-> has methods for calculations from a given time and/or date
_________________________
14.2.2. HUMAN DATE & TIME
-------------------------------

Month
-> instances for all months

DaysOfWeek
-> instances for all dayNames
__________________________
14.2.3. LOCAL DATE & TIME
--------------------------------------------------------------

1) LocalTime	-> Local time in hours, minutes, seconds, ...
2) LocalDate	-> Local date in years, months, days, ...
3) LocalDateTime-> Local date and time combined
__________________
14.2.4. TIMEZONES
------------------------------------------------------------------------

ZoneId name = ZoneId.of("Region/City")

1) ZoneId = gives date and/or time from given region and city.
2) ZoneOffSet = gives date and/or time from given difference of UTC
____________________
14.2.5. TIMEDURATION
---------------------------------------------------------------------------

1) Duration = differences of the Instant-class
2) ChronoUnit = enumeration of different time-units between 2 given times.
3) Period = gives time-differences in human notations
_______________________
14.2.6. DATE-FORMATTING
---------------------------------------------------------------------------

DateTimeFormatter = uses patterns to format time and/or date 
in specified format (see also 8.3. FORMATTER)

tY	-> yyyy (years)
ty	-> yy (years)
tB	-> month, entire name
tb	-> month, abbreviated
tm	-> mm (month)
td	-> dd (day)
tH	-> hours /24
tl	-> hours /12
tM	-> mm (minutes)
tS	-> ss (seconds)

______________
15. INTERFACES
-----------------------------------------------------------------------------

Definition: collection of abstract methods for use in objects.

- Gives different objects indentical behaviour 
(even in case of different superclass).
- Implementing methods
- Indirect use of object (by interface not the class itself).
- Can be used for collecting constant values.

-> In general name should end on -able

public interface InterfaceName extends SuperInts {
	...
}

-> All methods are implicitly public and abstract
-> All params are also implicitly public, static and final.
-> Methods can be static or void.
-> New object can be made out of interface
(InterfaceName name = new Object(); -where the Object implements the right interface)

_________________________________
16. NESTED AND ANONYMOUS CLASSES
------------------------------------------------------------------------------

-> Class within another Class
___________________
16.1. INNER CLASSES
-----------------------------------------------------------------------------

public class OuterClass {
	...
	public class InnerClass {
	...
	}
	...
}

-full name = OuterClass.InnerClass-

to make an object of the InnerClass:
- from withing the OuterClass	-> InnerClass name = new InnerClass ();
- from another Class		-> OuterClass outerName = new OuterClass();
+	-> OuterClass.InnerClass innerName = outerName.new Innerclass();

to reference a this of OuterClass within an InnerClas:
use: OuterClass.this
_________________________
16.2. LOCAL INNER CLASSES
----------------------------------------------------------------------

-> inner class within a method of outer class
-> they have only acces to variables within the method 
that are therefor implicitly final

public class OuterClass {
	public void aMethod () {
	final var = x;
	class LocalInnerClass {
	...
	}
}}
______________________________
16.3. ANONYMOUS INNER CLASSES
-------------------------------------------------------------------

-> Inner Classes without name, defined when created into Objects

public class OuterClass {
	...
	public void method () {
	SuperClass object1 = new SuperClass () {
	//Implementations and/or Overrides
	};
	Interface object2 = new Interface() {
	//Implementations
	};
	}
{
____________________________
16.4. STATIC NESTED CLASSES
-------------------------------------------------

public class OuterClass {
	public static class InnerClass {
	}
}

-> Static Nested classes can not acces directly 
outerclass-properties & -methods.

Other example of Static nested class (as enum):
public class OuterClass {
	public enum EnumClass {
	...
	}
}

(nested enums can not be defined within methods)

______________________
17. EXCEPTION HANDLING
---------------------------------------------------------------------------

- Handels exceptions grouped and separated from rest of code.
- Does call stack (back to front)
- Can handle exception at top of hierarchy 
(so an exception for a superclass can be handled as wel for all subclasses)

catching exceptions:

try {
	statements;
	} catch (ExceptionName en) {
	//actions to do
	} catch (OtherException oe) {
	//actions to do
	}

catching multiple exceptions

try {
	statements;
	} catch (ExceptionName|OtherException e) {
	//actions todo
	}

with finally codeblock:

try {
	...
	} catch () {
	...
	} finally {
	...
}

-> even when Exception hit, finally-block will always be carried out.

throw exceptions:

public void method () throws Exception {
	if (condition) throw new exception ();
	else statements;
}
_______________________
17.1. EXCEPTION-CLASSES
-------------------------------------------------------

public class ExceptionName extends ExistingException {
	ExceptionConstructors for ex. message, cause;
}

______________
18. GENERICS
----------------------------------------------------------------------

public class ClassName <E1,E2> {
	private E1 name;
	private E2 secondName;

public ClassName (E1 name, E2 secondName){
	this.name = name;
	this.secondName = secondName;
	}
}

-To explicitely use a certain kind of type <E> can be replaced by
-><E extends ...>
-(... ex. Number, ...)-

-if the generic to be used is not known 
you can use the wildcar (= ?) with a height-limit
-> example: <? extends Number>

-or to exlude subclasses
-> <? super Number>

-for arrays alwas use wildcard

______________________
19. LAMBDA-EXPRESSIONS
---------------------------------------------------------------------------
____________________________
19.1. FUNCTIONAL INTERFACES
-----------------------------------

-Can only have one abstract method

@FunctionalInterface
public interface Name {
	...;
}
______________________________
19.2. BASIC LAMBDA-EXPRESSIONS
-------------------------------------------------------------------------

defining lambda-expression (example):
object.methodImplementingFI ((String s) -> s.contains("e"));

The 3 parts of lambda-expressions:
1) params: (String s) OR (var s) OR (s) OR s
2) arrow: ->
3) body: expression or codeblock that implements the functional method
_______________________
19.3. METHOD-REFERENCES
-------------------------------------

qualifier::identifier

for static methods:
-> className::staticMethodName

for methods of bounded objects:
-> objectName::methodName

for methods of unbounded objects:
-> ParameterType::methodName

for constructor-references:
-> ClassName::new
__________________________________
19.4. BASIC FUNCTIONAL INTERFACES
----------------------------------------------------------------

1) Predicate<T>
	abstract method:
	public boolean test (T t);
	
	default-methods:
	and(Predicate <? super T> other)
	or(Predicate <? super T> other)
	negate()

2)Function<T,R>
	abstract method:
	public R apply (T t);

	default)methods:
	andThen (Function <? super R, ? extends V> after)
	compose (Function <? super V, ? extends T> before)

3)Consumer<T>
	abstract method:
	public void accept (T t);

	default method:
	andThen (Consumer<? super T> after)

______________
20. STREAMING
------------------------------------

example:
int [] numbers = {1,2,3,4,5,6};

Stream

Enter source:
.of(numbers)

Iterator:
.forEach();
________________
20.1. SOURCES
-------------------------------------

sorts of Streams:
1)Stream<T>: generic objects
2)IntStream: stream of integers
3)LongStream: stream of longs
4)DoubleStream: stream of doubles

sources of Streams:
1)collection of elements
2)generator
3)I/O-channel

Generate Stream:
.generate()
	abstract method:
	public T get();

not-generic objects:
	methods:
	.range()
	.rangeClosed()
	.iterate(initNumber,functionalMethod)
		functionalMethod:
		public int applyAsInt (int operand);
________________
20.2. OPERATIONS
-----------------------------------------------------------
_______________________________
20.2.1. INTERMEDIATE OPERATIONS
-----------------------------------------------------------

1) Filter: new stream with elements of given requirements
2) Conversion: new stream with converted elements
3) Sorting: new stream with sorted elements of first stream
_________________
20.2.1.1. FILTERS
-------------------------------------------------------

.filter(lambda-expression)

-can contain multiple filters

pre-existing filters:
.distinct() => removes all duplicates
.limit() => limits the number of elements to keep
.skip() => skips certain elements
_____________________
20.2.1.2. CONVERSION
----------------------------------------------------------------

method-examples:
IntStream mapToInt (ToIntFunction<? super T> mapper)
LongStream mapToLong (ToLongFunction<? super T> mapper)
DoubleStream mapToDouble (ToDoubleFunction<? super T> mapper)
<R> Stream<R> map (Function<? super T,? extends R> mapper)

use-examples:
.mapToInt(lambda-expression)
.map(lambda-expression)
__________________
20.2.1.3. SORTING
--------------------------------------------------------------

.sorted()
(uses automatic generated sorting algorithm from Comparator)
_______________________
20.2.2. END-OPERATIONS
---------------------------------

1) Nothing (consuming)
2) New data (reducing)
3) New collection (collecting)
______________________________
20.2.2.1. CONSUMING OPERATIONS
-----------------------------------------

.forEach (Consumer<? super T> action)

example:
Stream.of(input)
	.forEach(System.out::println);
_______________________________
20.2.2.2. REDUCING OPERATIONS
------------------------------------------------------

.sum() - example:
int sum = IntStream.rangeClosed(begin,end)
			.sum();

.max() - example:
OptionalInt max = IntStream.rangeClosed(begin,end)
				.max();

Usercreated reduce-operation:
.reduce(begin,(acc,el)->acc//doSomething//el);

->begin = optional beginValue
->acc = accumulationValue
->el = elementValue
->doSomething = operation to do
_______________________________
20.2.2.3. COLLECTING OPERATIONS
--------------------------------

.collect()

Array-example:
.toArray();

________________
21. COLLECTIONS
----------------------------------------------------------------
___________________________
21.1. COLLECTIONS FRAMEWORK
-----------------------------------------------------

possibilities:
1) Adding an object at a collection
2) Removing an object from a collection
3) Checking if an object is present in a collection
4) Request an object from a collection
5) Iterate a collection
_____________________________________
21.2. COLLECTIONS AND IMPLEMENTATIONS
----------------------------------------------------------------

basic methods:
boolean add (E e) => add element to collection
boolean remove (Object o) => remove element from collection
void clear () => removes all elements from a collection
boolean contains (Object o) => checks if an element is present
Iterator<E> iterator () => iterates the collection
int size() => gives the number of elements in a collection
forEach() => iterates collection and uses functional method
stream() => gives a stream of all elements in a collection

Iterator-methods basics:
.hasnext() => show if there is a next element
.next() => gives the next element
____________
21.2.1. LIST
------------------------------------------------------------------

List is a subclass of Collection thus inherites all methods

-A list is ordened
-Duplicates are possible
-IndexValue

basic methods:
-> Collection-methods

+

void add (int index, E e) => adds element on given position 
				(rest is shifted)
void set (int index, E e) => replaces element on given position
E get (int index) => gives element on given position
E remove (int index) => removes element on given position
				(rest is shifted)
___________________
21.2.1.1. ARRAYLIST
--------------------------------

-Quick random acces by index

methods: see List-methods
____________________
21.2.1.2. LINKEDLIST
--------------------------------------------

-Quick adding, removing etc...
-Each element is linked before and after

methods: 
List-methods (21.2.1.) 
+ 
Duque-methods (21.2.3.2.)
___________
21.2.2. SET
-----------------------------------

-No duplicates
-No index

methods: see Collection-methods
_________________
21.2.2.1. HASHSET
-------------------------------

-Not ordened
-Not sorted
-Quick random acces

methods: see Collection-methods
_______________________
21.2.2.2. LINKEDHASHSET
---------------------------------

-Ordened
-Not sorted
-Quick random acces

methods: see Collection-methods
_____________________
21.2.2.3. SORTEDSET
-----------------------------------

-Ordened
-Sorted

methods:
-> Set-methods

+

E  first() => gives first element
E last() => gives last element
__________________________
21.2.2.3.BIS. NAVIGABLESET
---------------------------------------------------------------

methods:
-> SortedSet-methods

+

E ceiling() => gives element that is bigger or equal 
		to a given element
E floor() => gives element that is smaller or equal
		to a given element
E higher() => gives next element bigger than given element
E lower() => gives next element lower than given element
__________________________
21.2.2.3.BIS.BIS. TREESET
---------------------------------

-Treestructured

methods: See Collection-methods
______________
21.2.3. QUEUE
------------------------------------------------------------

-Ordened

methods:
-> Collection-methods

+

offer (E e) => adds element to a queue
E peek()	=> gives next element but doesn't remove it
		=> gives null when queue is empty
E element() 	=> gives next element but doesn't remove it
		=> throws exception when queue is empty
E poll()	=> gives next element and removes it
		=> gives null when queue is empty
E remove()	=> gives next element and removes it
		=> throws exception when queue is empty
________________________
21.2.3.1. PRIORITYQUEUE
--------------------------

methods: see Queuemethods
_________________
21.2.3.2. DEQUE
------------------------------------------------------

-Head- and tail-access

methods:
-> Queuemethods

offerfirst (E e) - addFirst (E e)
=> adds element at head
E peekFirst() - E getFirst()
=> gives next element at head but doesn't remove it
E pollFirst() - E removeFirst()
=> gives next element at head and removes it
offerLast (E e) - addLast (E e)
=> adds element at tail
E peekLast() - E getLast()
=> gives next element at tail but doesn't remove it
E pollLast() - E removeLast()
=> gives next element at tail and removes it
______________________
21.2.3.2.1. LINKEDLIST
----------------------

(see 21.2.1.2.)
_______________________
21.2.3.2.2. ARRAYDEQUE
---------------------------

methods: see Deque-methods
________________________________________________
21.2.4. COMPARISON OF COLLECTION-IMPLEMENTATIONS
--------------------------------------------------------

		Unique |Ordened |Sorted |Random Access
HashSet		   X	   O	   O		O
LinkedHashSet	   X	   X	   O		O
TreeSet		   X	   X	   X		O
LinkedList	   O	   X	   O		O
ArrayList	   O	   X	   O		X
PriorityQue	   O	   X	   X		O
Duque		   O	   X	   O		O
___________________________
21.2.5. Sorting collections
---------------------------
____________________________
21.2.5.1. intrinsic sorting
----------------------------
Sorting by collection-methods (like SortedSet, Treeset, PriorityQueue, ...)

Types of sorting:

1) Natural order by implementing the Comparable<T> interface.
method:
public int compareTo (T o)
-> gives negative value when the element is lower then the given element
-> gives positive value when the element is higher then the given element

2) Comparator sorting determined by comparator implemented by constructor
! Do not implement Comparable interface !
-> the constructor implements the Comparator-interface

method:
public int compare (T object, T object2)
-> can be used if the object to compare don't hava a natural order
-> can be used if another order is desirable

-sorting collections only accept element that implements
the needed interface, if not an exception will be thrown-

-> Comparator also has a method .thenComparing() for further comparison

-> in a TreeSet duplicates will throw a value of 0


sources :
Java 11 Fundamentals - Noël Vaes
